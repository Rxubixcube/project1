<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Explorer & Editor (Responsive)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        // Import Firebase components
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set log level for debugging
        setLogLevel('debug');

        // Global variables provided by the environment (MANDATORY)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- GAME CONSTANTS (GRID LOGIC REMAINS FIXED) ---
        const MAP_SIZE = 20; // 20x20 tiles
        const LERP_FACTOR = 0.15; // Controls the speed of smooth movement
        const TRAIL_FADE_RATE = 0.05;
        const SWING_DURATION = 300; // Duration of the swing animation in ms

        const CURRENCY_NAME = 'Gold';
        const STARTING_GOLD = 500;
        const MEGA_GOLD_AMOUNT = 1000000; // New constant for the cheat amount
        
        // Weapon templates define base stats and repair cost
        const WEAPON_TEMPLATES = {
            'sword': { name: 'Iron Sword', baseAttack: 5, baseDurability: 50, repairCost: 50 },
            'bow': { name: 'Advanced Bow', baseAttack: 4, baseDurability: 40, repairCost: 40 },
            'katana': { name: 'Samurai Katana', baseAttack: 6, baseDurability: 45, repairCost: 60 }
        };
        const DURABILITY_BONUS_PER_LEVEL = 25;
        const ATTACK_BONUS_PER_LEVEL = 3;

        // Enemy Templates
        const ENEMY_TEMPLATES = {
            'weak_goblin': { name: 'Weak Goblin', maxHealth: 10, attack: 1, color: '#3c6e2b', killReward: 100 },
        };

        // Tile IDs and their properties
        const TILE_TYPES = {
            GRASS: 0, WALL: 1, WATER: 2, ROAD: 3, FOREST: 4, BUILDING: 5, TREE: 6,      
        };

        const TILE_PROPERTIES = [
            { id: TILE_TYPES.GRASS, name: 'Grass', color: '#689f38', traversable: true },
            { id: TILE_TYPES.WALL, name: 'Wall', color: '#5d4037', traversable: false },
            { id: TILE_TYPES.WATER, name: 'Water', color: '#03a9f4', traversable: false },
            { id: TILE_TYPES.ROAD, name: 'Road', color: '#bcaaa4', traversable: true },
            { id: TILE_TYPES.FOREST, name: 'Forest', color: '#4a6b2c', traversable: true },
            { id: TILE_TYPES.BUILDING, name: 'Building', color: '#795548', traversable: false }, 
            { id: TILE_TYPES.TREE, name: 'Tree', color: '#004d40', traversable: false },         
        ];

        // --- GAME STATE & DYNAMIC SIZING ---
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;

        let mapData = createEmptyMap(MAP_SIZE);
        let player = { 
            x: 9, y: 9, visualX: 9, visualY: 9,
            currency: 0, weapon: null 
        }; 
        let mode = 'play'; 
        let gameState = 'menu'; 
        
        let enemies = []; 
        let enemyAIInterval = null;

        // Dynamic Sizing Variables (CRITICAL for responsiveness)
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        let currentCanvasSize = 800; // Will be set on load/resize
        let currentTilePixelSize = 40; // currentCanvasSize / MAP_SIZE

        // Animation state
        let isMoving = false; 
        let isSwinging = false; 
        let animationFrameId = null; 
        let trailEffect = { x: -1, y: -1, opacity: 0 }; 
        
        // Utility for creating simple unique IDs
        function simpleUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }


        // --- FIREBASE SETUP & DATA HANDLING (Unchanged from working version) ---

        async function initFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing.");
                    document.getElementById('message-box').innerHTML = createMessage('error', 'Firebase configuration is missing. Cannot save data.');
                    return;
                }
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        if (!userId) { 
                            userId = user.uid;
                            isAuthReady = true;
                            document.getElementById('user-id-display').textContent = `User ID: ${userId}`;
                            console.log("Authentication successful. User ID:", userId);
                            startListeners();
                            player.visualX = player.x; 
                            player.visualY = player.y;
                            player.weapon = player.weapon || initializePlayerWeapon();
                            if (gameState === 'game' && !animationFrameId) {
                                animate();
                            }
                        }
                    } else {
                        console.log("No user signed in.");
                        isAuthReady = true; 
                    }
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                
            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                document.getElementById('message-box').innerHTML = createMessage('error', `Authentication failed: ${error.message}`);
            }
        }

        function getMapDocRef() {
            return doc(db, 'artifacts', appId, 'public', 'data', 'exploration_game', 'main_map');
        }

        function getPlayerStateDocRef(uid) {
            return doc(db, 'artifacts', appId, 'users', uid, 'game_state', 'player_state');
        }

        function initializePlayerWeapon(type = 'sword') {
            const newWeapon = { type: type, level: 1, currentDurability: 0 };
            return calculateWeaponStats(newWeapon);
        }

        function calculateWeaponStats(weapon) {
            const template = WEAPON_TEMPLATES[weapon.type];
            const level = weapon.level;
            const maxDurability = template.baseDurability + (level - 1) * DURABILITY_BONUS_PER_LEVEL;
            const attackPower = template.baseAttack + (level - 1) * ATTACK_BONUS_PER_LEVEL;
            
            weapon.maxDurability = maxDurability;
            weapon.attackPower = attackPower;
            
            if (weapon.currentDurability === undefined || weapon.currentDurability > maxDurability) {
                weapon.currentDurability = maxDurability;
            }
            return weapon;
        }

        function upgradeWeapon() {
            if (!player.weapon) return;
            if (player.weapon.currentDurability < player.weapon.maxDurability) {
                document.getElementById('message-box').innerHTML = createMessage('warning', `Weapon must be fully repaired before upgrading!`);
                return;
            }
            
            const nextLevel = player.weapon.level + 1;
            const upgradeCost = WEAPON_TEMPLATES[player.weapon.type].repairCost * nextLevel * nextLevel; 

            if (player.currency < upgradeCost) {
                document.getElementById('message-box').innerHTML = createMessage('error', `Not enough ${CURRENCY_NAME}! Requires ${upgradeCost}.`);
                return;
            }

            player.currency -= upgradeCost;
            player.weapon.level = nextLevel;
            
            player.weapon = calculateWeaponStats(player.weapon); 
            player.weapon.currentDurability = player.weapon.maxDurability;

            document.getElementById('message-box').innerHTML = createMessage('success', `Weapon upgraded to Level ${nextLevel}! Cost: ${upgradeCost} ${CURRENCY_NAME}.`);
            savePlayerState();
            updateWeaponUI();
        }

        function repairWeapon() {
            if (!player.weapon) return;
            if (player.weapon.currentDurability === player.weapon.maxDurability) {
                document.getElementById('message-box').innerHTML = createMessage('info', `Weapon durability is already full.`);
                return;
            }

            const missingDurability = player.weapon.maxDurability - player.weapon.currentDurability;
            const repairCost = missingDurability * 1; 

            if (player.currency < repairCost) {
                document.getElementById('message-box').innerHTML = createMessage('error', `Not enough ${CURRENCY_NAME}! Requires ${repairCost} to fully repair.`);
                return;
            }

            player.currency -= repairCost;
            player.weapon.currentDurability = player.weapon.maxDurability;

            document.getElementById('message-box').innerHTML = createMessage('success', `Weapon fully repaired! Cost: ${repairCost} ${CURRENCY_NAME}.`);
            savePlayerState();
            updateWeaponUI();
        }

        function useWeapon() {
            if (!player.weapon || isSwinging) return; 
            
            if (player.weapon.currentDurability <= 0) {
                document.getElementById('message-box').innerHTML = createMessage('warning', `Weapon is broken! Must be repaired.`);
                return;
            }
            
            const damage = Math.floor(Math.random() * 5) + 1;
            player.weapon.currentDurability = Math.max(0, player.weapon.currentDurability - damage);

            const targetsHit = [];
            const playerTileX = player.x;
            const playerTileY = player.y;

            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const targetX = playerTileX + dx;
                    const targetY = playerTileY + dy;
                    
                    if (targetX < 0 || targetX >= MAP_SIZE || targetY < 0 || targetY >= MAP_SIZE) continue;

                    const hitEnemy = enemies.find(e => e.x === targetX && e.y === targetY);
                    if (hitEnemy) {
                        targetsHit.push(hitEnemy.id);
                    }
                }
            }

            let enemiesKilled = 0;
            let message = `Swung sword! Durability lost: ${damage}.`;

            if (targetsHit.length > 0) {
                enemies = enemies.map(enemy => {
                    if (targetsHit.includes(enemy.id)) {
                        const damageDealt = player.weapon.attackPower;
                        enemy.health -= damageDealt;
                        
                        if (enemy.health <= 0) {
                            enemiesKilled++;
                            player.currency += ENEMY_TEMPLATES[enemy.type].killReward; 
                            return null; 
                        }
                    }
                    return enemy;
                }).filter(e => e !== null); 

                message = `Swung sword! Hit ${targetsHit.length} target(s) for ${player.weapon.attackPower} damage each.`;
                if (enemiesKilled > 0) {
                    message += ` Killed ${enemiesKilled} Goblin(s)! Gained ${enemiesKilled * 100} ${CURRENCY_NAME}.`;
                }
                document.getElementById('message-box').innerHTML = createMessage('combat', message); 
            } else {
                document.getElementById('message-box').innerHTML = createMessage('info', `Swung sword! No enemies hit. ${message}`);
            }

            if (player.weapon.currentDurability === 0) {
                document.getElementById('message-box').innerHTML = createMessage('error', `Weapon BROKEN! Please repair it now.`);
            }

            isSwinging = true;
            const swordVisual = document.getElementById('swordVisual');
            swordVisual.classList.add('swinging');
            
            setTimeout(() => {
                swordVisual.classList.remove('swinging');
                isSwinging = false;
            }, SWING_DURATION);

            saveMapToFirestore(mapData); 
            savePlayerState();
            updateWeaponUI();
        }

        /**
         * ADMIN/CHEAT FUNCTION: Grants 1,000,000 Gold only in Edit Mode.
         */
        function grantMegaGold() {
            if (gameState !== 'game') {
                document.getElementById('message-box').innerHTML = createMessage('warning', 'Game must be running to use this command.');
                return;
            }
            if (mode === 'edit') {
                player.currency += MEGA_GOLD_AMOUNT;
                savePlayerState();
                updateWeaponUI();
                document.getElementById('message-box').innerHTML = createMessage('success', `ADMIN: Granted ${MEGA_GOLD_AMOUNT.toLocaleString()} ${CURRENCY_NAME}. Go buy some upgrades!`);
            } else {
                document.getElementById('message-box').innerHTML = createMessage('error', 'Cheat command failed. Must be in EDIT mode to use the ADMIN tools.');
            }
        }


        function spawnInitialEnemies(count) {
            const newEnemies = [];
            const enemyTemplate = ENEMY_TEMPLATES['weak_goblin'];
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * MAP_SIZE);
                    y = Math.floor(Math.random() * MAP_SIZE);
                } while (!isTileTraversable(x, y) || (x === player.x && y === player.y));

                newEnemies.push({
                    id: simpleUUID(),
                    type: 'weak_goblin',
                    x: x,
                    y: y,
                    health: enemyTemplate.maxHealth,
                    maxHealth: enemyTemplate.maxHealth,
                });
            }
            return newEnemies;
        }

        function startEnemyAI() {
            stopEnemyAI();
            enemyAIInterval = setInterval(() => {
                if (gameState !== 'game' || mode !== 'play' || isSwinging) return;
                
                let moved = false;
                enemies = enemies.map(enemy => {
                    if (Math.random() < 0.1) {
                        const dx = Math.floor(Math.random() * 3) - 1; 
                        const dy = Math.floor(Math.random() * 3) - 1; 
                        const newX = enemy.x + dx;
                        const newY = enemy.y + dy;

                        if (isTileTraversable(newX, newY) && !(newX === player.x && newY === player.y)) {
                            enemy.x = newX;
                            enemy.y = newY;
                            moved = true;
                        }
                    }
                    return enemy;
                });
                
                if (moved) {
                    drawGame(); 
                    saveMapToFirestore(mapData);
                }
            }, 1000); 
        }

        function stopEnemyAI() {
            if (enemyAIInterval) {
                clearInterval(enemyAIInterval);
                enemyAIInterval = null;
            }
        }

        function createEmptyMap(size) {
            return Array(size).fill(0).map(() => Array(size).fill(TILE_TYPES.GRASS));
        }

        function generateProceduralMap() {
            const newMap = createEmptyMap(MAP_SIZE);
            let riverY = Math.floor(MAP_SIZE * 0.3 + Math.random() * MAP_SIZE * 0.4); 
            
            for (let x = 0; x < MAP_SIZE; x++) {
                if (riverY >= 0 && riverY < MAP_SIZE) {
                    newMap[riverY][x] = TILE_TYPES.WATER;
                }
                if (riverY + 1 < MAP_SIZE) newMap[riverY + 1][x] = TILE_TYPES.WATER;

                const shift = Math.floor(Math.random() * 3) - 1; 
                riverY += shift;
                riverY = Math.max(0, Math.min(MAP_SIZE - 2, riverY));
            }

            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (newMap[y][x] === TILE_TYPES.WATER) continue;
                    if (Math.random() < 0.10) { 
                        newMap[y][x] = TILE_TYPES.TREE;
                    } else if (Math.random() < 0.05) { 
                        newMap[y][x] = TILE_TYPES.FOREST;
                    }
                }
            }
            
            newMap[player.y][player.x] = TILE_TYPES.GRASS;
            return newMap;
        }

        function startListeners() {
            if (!isAuthReady || !userId || !db) return;

            onSnapshot(getMapDocRef(), (docSnapshot) => {
                let enemiesNeedSaving = false;
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    if (data.tiles) {
                        try { mapData = JSON.parse(data.tiles); } catch (e) {
                            console.error("Error parsing map data:", e);
                            document.getElementById('message-box').innerHTML = createMessage('error', 'Map data corruption detected. Resetting map.');
                            mapData = createEmptyMap(MAP_SIZE);
                        }
                    }
                    if (data.enemies) { 
                        try {
                            const loadedEnemies = JSON.parse(data.enemies);
                            enemies = loadedEnemies.map(e => ({ ...e, id: e.id || simpleUUID() }));
                        } catch (e) {
                            console.error("Error parsing enemies data:", e);
                            document.getElementById('message-box').innerHTML = createMessage('error', 'Enemy data corruption detected. Resetting enemies.');
                            enemies = [];
                        }
                    } else if (gameState === 'game' && enemies.length === 0) {
                        enemies = spawnInitialEnemies(5);
                        enemiesNeedSaving = true; 
                    }
                } else {
                    mapData = createEmptyMap(MAP_SIZE);
                    enemies = spawnInitialEnemies(5);
                    enemiesNeedSaving = true;
                }
                if (enemiesNeedSaving) saveMapToFirestore(mapData);
            }, (error) => {
                console.error("Error listening to map data:", error);
            });

            onSnapshot(getPlayerStateDocRef(userId), (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    player.x = data.x ?? player.x;
                    player.y = data.y ?? player.y;
                    player.currency = data.currency ?? STARTING_GOLD; 
                    if (data.weapon) {
                        try {
                            const loadedWeapon = JSON.parse(data.weapon);
                            player.weapon = calculateWeaponStats(loadedWeapon);
                            player.weapon.currentDurability = loadedWeapon.currentDurability ?? player.weapon.maxDurability;
                        } catch (e) {
                            player.weapon = initializePlayerWeapon();
                        }
                    } else {
                        player.weapon = initializePlayerWeapon();
                    }
                    if (gameState === 'game') {
                        updateWeaponUI();
                        if (!animationFrameId) animate();
                    }
                } else {
                    player.currency = STARTING_GOLD;
                    player.weapon = initializePlayerWeapon();
                    savePlayerState();
                }
            }, (error) => {
                console.error("Error listening to player state:", error);
            });
        }

        async function saveMapToFirestore(newMap = mapData) {
            if (!isAuthReady || !userId || !db) return;
            try {
                const serializedMap = JSON.stringify(newMap);
                const serializedEnemies = JSON.stringify(enemies); 
                await setDoc(getMapDocRef(), {
                    tiles: serializedMap, enemies: serializedEnemies, last_updated: new Date().toISOString(), editor_id: userId
                });
                if (mode === 'edit') document.getElementById('message-box').innerHTML = createMessage('success', 'Map updated and saved.');
            } catch (error) {
                console.error("Error saving map:", error);
                document.getElementById('message-box').innerHTML = createMessage('error', `Save failed: ${error.message}`);
            }
        }

        async function savePlayerState() {
            if (!isAuthReady || !userId || !db) return;
            try {
                await setDoc(getPlayerStateDocRef(userId), {
                    x: player.x, y: player.y, currency: player.currency,
                    weapon: JSON.stringify({
                        type: player.weapon.type, level: player.weapon.level, currentDurability: player.weapon.currentDurability
                    }),
                    last_update: new Date().toISOString()
                }, { merge: true });
            } catch (error) {
                console.error("Error saving player state:", error);
            }
        }

        // --- RESIZING AND SCALING LOGIC (NEW) ---
        
        /**
         * Dynamically adjusts canvas size based on its container, ensuring a square aspect ratio.
         */
        function handleResize() {
            const container = document.getElementById('game-container');
            if (!container || !ctx) return;
            
            // Determine the maximum square size the container can hold
            const size = container.clientWidth; 
            
            // Update the global dynamic size variables
            currentCanvasSize = size;
            currentTilePixelSize = currentCanvasSize / MAP_SIZE;

            // Apply the new size to the canvas element
            canvas.width = currentCanvasSize;
            canvas.height = currentCanvasSize;
            
            // Redraw the game to fill the new dimensions
            if (gameState === 'game') {
                drawGame(); 
            }
        }
        
        // --- GAME CANVAS DRAWING & ANIMATION (SCALED) ---

        function animate() {
            // Interpolate visual position (Smooth Movement)
            const targetX = player.x;
            const targetY = player.y;

            player.visualX += (targetX - player.visualX) * LERP_FACTOR;
            player.visualY += (targetY - player.visualY) * LERP_FACTOR;

            const distanceSquared = (targetX - player.visualX)**2 + (targetY - player.visualY)**2;
            
            if (distanceSquared < 0.001) { 
                player.visualX = player.x;
                player.visualY = player.y;
                isMoving = false;
            } else {
                isMoving = true;
            }

            // Update weapon visual position
            const weaponVisual = document.getElementById('playerWeaponVisual');
            if (weaponVisual && gameState === 'game' && mode === 'play') {
                // Use SCALED position
                const visualLeft = player.visualX * currentTilePixelSize + currentTilePixelSize / 2;
                const visualTop = player.visualY * currentTilePixelSize + currentTilePixelSize / 2;
                weaponVisual.style.transform = `translate(${visualLeft}px, ${visualTop}px)`;
                weaponVisual.style.display = 'block';
            } else if (weaponVisual) {
                 weaponVisual.style.display = 'none';
            }

            // Fade out trail effect
            if (trailEffect.opacity > 0) {
                trailEffect.opacity = Math.max(0, trailEffect.opacity - TRAIL_FADE_RATE);
            }

            // Redraw the entire game state
            drawGame();

            // Loop: Continue if in game state or if movement/effects are ongoing
            if (gameState === 'game' || isMoving || trailEffect.opacity > 0 || isSwinging) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                animationFrameId = null; 
            }
        }

        // Helper function to draw the avatar icon with smooth effects
        function drawAvatar(x, y, size) {
            
            let scaleFactor = 1.0;
            if (isMoving) {
                const time = performance.now() * 0.005; 
                scaleFactor = 1.0 + Math.abs(Math.sin(time * 5)) * 0.1; 
            }

            const centerX = x * size + size / 2;
            const centerY = y * size + size / 2;
            const headRadius = size / 3;
            const bodyHeight = size / 2;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(scaleFactor * 0.9, scaleFactor * 0.9); 
            ctx.translate(-centerX, -centerY);

            // Head
            ctx.fillStyle = '#b7a288'; 
            ctx.beginPath();
            ctx.arc(centerX, centerY - headRadius / 2, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.fillStyle = '#787d83'; 
            ctx.fillRect(centerX - headRadius, centerY + headRadius * 0.5, headRadius * 2, bodyHeight);
            
            ctx.restore(); 
        }

        function drawTree(x, y) {
            const size = currentTilePixelSize;
            const startX = x * size;
            const startY = y * size; 

            const baseGrassColor = TILE_PROPERTIES[TILE_TYPES.GRASS].color;
            const trunkColor = '#8d6e63'; 
            const darkGreen = '#004d40'; 
            const lightGreen = '#388e3c'; 

            ctx.fillStyle = baseGrassColor;
            ctx.fillRect(startX, startY, size, size);

            const trunkWidth = size * 0.2;
            const trunkHeight = size * 0.4;
            const trunkX = startX + (size - trunkWidth) / 2;
            const trunkY = startY + size - trunkHeight;
            ctx.fillStyle = trunkColor;
            ctx.fillRect(trunkX, trunkY, trunkWidth, trunkHeight);

            const canopyRadius = size * 0.45;
            const centerX = startX + size / 2;
            const centerY = startY + size * 0.3; 

            // Shadow Layer
            ctx.fillStyle = darkGreen;
            ctx.beginPath();
            ctx.arc(centerX + size * 0.075, centerY + size * 0.125, canopyRadius, 0, Math.PI * 2);
            ctx.fill();

            // Main Layer
            ctx.fillStyle = darkGreen;
            ctx.beginPath();
            ctx.arc(centerX, centerY, canopyRadius, 0, Math.PI * 2);
            ctx.fill();

            // Highlight Layer
            ctx.fillStyle = lightGreen;
            ctx.beginPath();
            ctx.ellipse(centerX - size * 0.125, centerY - size * 0.125, canopyRadius * 0.7, canopyRadius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ground Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(centerX, startY + size - size * 0.125, trunkWidth * 2, trunkWidth * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawHealthBar(x, y, current, max) {
            const tileP = currentTilePixelSize;
            const startX = x * tileP;
            const startY = y * tileP;
            const barWidth = tileP * 0.75;
            const barHeight = tileP * 0.1; 
            const barX = startX + (tileP - barWidth) / 2;
            const barY = startY - barHeight; 

            const healthPct = current / max;
            let color = 'red';
            if (healthPct > 0.5) color = '#4ade80'; 
            else if (healthPct > 0.2) color = '#facc15'; 

            // Background bar
            ctx.fillStyle = '#1f2937'; 
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Foreground health bar
            ctx.fillStyle = color;
            ctx.fillRect(barX, barY, barWidth * healthPct, barHeight);

            // Border
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5 * (currentCanvasSize / 800); // Scale border thickness
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawGame() {
            if (!ctx) return;
            const tileP = currentTilePixelSize;

            // 0. Draw Fading Trail 
            if (trailEffect.opacity > 0) {
                const trailX = trailEffect.x * tileP + tileP / 2;
                const trailY = trailEffect.y * tileP + tileP / 2;
                ctx.fillStyle = `rgba(255, 255, 255, ${trailEffect.opacity * 0.5})`; 
                ctx.beginPath();
                ctx.arc(trailX, trailY, tileP * 0.4 * (1 + (1 - trailEffect.opacity)), 0, Math.PI * 2); 
                ctx.fill();
            }

            // 1. Draw the map
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const tileId = mapData[y] ? mapData[y][x] : TILE_TYPES.GRASS;
                    const tile = TILE_PROPERTIES.find(p => p.id === tileId) || TILE_PROPERTIES[0];
                    
                    if (tileId === TILE_TYPES.TREE) {
                        drawTree(x, y);
                    } else {
                        ctx.fillStyle = tile.color;
                        ctx.fillRect(x * tileP, y * tileP, tileP, tileP);
                    }
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.strokeRect(x * tileP, y * tileP, tileP, tileP);

                    if (mode === 'edit') {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.strokeRect(x * tileP, y * tileP, tileP, tileP);
                    }
                }
            }

            // 2. Draw Enemies
            enemies.forEach(enemy => {
                const template = ENEMY_TEMPLATES[enemy.type];
                if (!template) return;

                const centerX = enemy.x * tileP + tileP / 2;
                const centerY = enemy.y * tileP + tileP / 2;
                const size = tileP * 0.6; 

                // Draw Goblin Body
                ctx.fillStyle = template.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw Health Bar
                drawHealthBar(enemy.x, enemy.y, enemy.health, enemy.maxHealth);
            });


            // 3. Draw the player
            if (mode === 'play') {
                drawAvatar(player.visualX, player.visualY, tileP);
            }

            // 4. Draw current mode indicator on canvas (Scaled text)
            ctx.fillStyle = mode === 'edit' ? 'rgba(255, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            const fontSize = Math.max(12, currentCanvasSize / 50); // Scale font size
            ctx.font = `700 ${fontSize}px Inter, sans-serif`;
            ctx.fillText(mode.toUpperCase(), currentCanvasSize * 0.0125, currentCanvasSize * 0.025);
        }

        // --- MOVEMENT & EDITOR LOGIC (SCALED INPUT) ---

        function isTileTraversable(x, y) {
            if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) return false;
            const tileId = mapData[y] ? mapData[y][x] : TILE_TYPES.GRASS;
            const tile = TILE_PROPERTIES.find(p => p.id === tileId);
            return tile ? tile.traversable : true;
        }

        function movePlayer(dx, dy) {
            if (gameState !== 'game' || mode !== 'play') return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            const hasEnemy = enemies.some(e => e.x === newX && e.y === newY);

            if (isTileTraversable(newX, newY) && !hasEnemy) {
                trailEffect.x = player.x;
                trailEffect.y = player.y;
                trailEffect.opacity = 1.0;

                player.x = newX;
                player.y = newY;

                savePlayerState(); 
                if (!animationFrameId) animate();

            } else if (hasEnemy) {
                document.getElementById('message-box').innerHTML = createMessage('info', 'Movement blocked by an enemy!');
            } else {
                 document.getElementById('message-box').innerHTML = createMessage('info', 'Movement blocked!');
            }
        }

        function handleTileClick(event) {
            if (gameState !== 'game' || mode !== 'edit') return;

            const rect = canvas.getBoundingClientRect();
            
            // CRITICAL: Calculate clicks based on the current canvas size
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Map click coordinates to the 20x20 grid
            const x = Math.floor(clickX / currentTilePixelSize);
            const y = Math.floor(clickY / currentTilePixelSize);

            if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                const currentTileId = mapData[y][x];
                const nextTileId = (currentTileId + 1) % TILE_PROPERTIES.length;

                const newMap = mapData.map(row => [...row]);
                newMap[y][x] = nextTileId;

                mapData = newMap;
                saveMapToFirestore(newMap);
            }
        }

        // --- UI DRAWING & GAME MODE LOGIC ---

        function updateWeaponUI() {
            if (!player.weapon) return;
            
            // Use toLocaleString for better formatting of large numbers
            document.getElementById('currency-display').textContent = `${CURRENCY_NAME}: ${player.currency.toLocaleString()} G`;

            const w = player.weapon;
            const template = WEAPON_TEMPLATES[w.type];
            const missingDurability = w.maxDurability - w.currentDurability;
            const repairCost = missingDurability * 1; 
            const upgradeCost = template.repairCost * (w.level + 1) * (w.level + 1);
            
            const durabilityPct = (w.currentDurability / w.maxDurability) * 100;
            let durabilityColor = 'bg-green-500';
            if (durabilityPct < 50) durabilityColor = 'bg-yellow-500';
            if (durabilityPct < 20) durabilityColor = 'bg-red-500';

            const weaponHtml = `
                <p class="text-lg font-bold">${template.name} <span class="text-indigo-600">(Lv. ${w.level})</span></p>
                <p class="text-sm">Attack Power: ${w.attackPower} <span class="text-gray-500">(+${w.attackPower - template.baseAttack})</span></p>
                
                <div class="mt-2">
                    <p class="text-xs font-medium">Durability: ${w.currentDurability} / ${w.maxDurability}</p>
                    <div class="w-full bg-gray-300 rounded-full h-2.5">
                        <div class="${durabilityColor} h-2.5 rounded-full transition-all duration-300" style="width: ${durabilityPct}%"></div>
                    </div>
                </div>
            `;
            
            document.getElementById('weapon-display').innerHTML = weaponHtml;

            const repairBtn = document.getElementById('repair-btn');
            const upgradeBtn = document.getElementById('upgrade-btn');

            repairBtn.disabled = w.currentDurability === w.maxDurability || player.currency < repairCost;
            upgradeBtn.disabled = w.currentDurability !== w.maxDurability || player.currency < upgradeCost;

            repairBtn.textContent = w.currentDurability === w.maxDurability ? 'Repaired (Full)' : `Repair (${repairCost.toLocaleString()} G)`;
            upgradeBtn.textContent = `Upgrade (Lv.${w.level + 1} - ${upgradeCost.toLocaleString()} G)`;
        }


        function startGame() {
            gameState = 'game';
            
            if (mapData.every(row => row.every(tile => tile === TILE_TYPES.GRASS))) {
                 const generatedMap = generateProceduralMap();
                 mapData = generatedMap; 
            }
            
            if (enemies.length === 0) {
                enemies = spawnInitialEnemies(5);
            }
            
            saveMapToFirestore(mapData); 
            
            player.currency = player.currency || STARTING_GOLD;
            player.weapon = player.weapon || initializePlayerWeapon();
            player.visualX = player.x;
            player.visualY = player.y;

            document.getElementById('app-content').classList.remove('hidden');
            document.getElementById('menu-screen').classList.add('hidden');
            
            mode = 'play'; 
            updateModeUI(); // Call new helper function to update all mode related UI
            
            updateWeaponUI(); 
            startEnemyAI(); 
            if (!animationFrameId) animate();
            handleResize(); // Initial resize call after starting game
        }

        function updateModeUI() {
            document.getElementById('mode-status').textContent = `Current Mode: ${mode.toUpperCase()}`;
            document.getElementById('mode-toggle-btn').textContent = mode === 'play' ? 'Switch to Edit Mode' : 'Switch to Play Mode';
            document.getElementById('edit-instruction').style.display = mode === 'edit' ? 'block' : 'none';
            document.getElementById('play-instruction').style.display = mode === 'play' ? 'block' : 'none';
            
            // Show/Hide admin button based on mode
            const megaGoldBtn = document.getElementById('mega-gold-btn');
            if(megaGoldBtn) {
                megaGoldBtn.style.display = mode === 'edit' ? 'block' : 'none';
            }
        }

        function toggleMode() {
            if (gameState !== 'game') return;

            mode = mode === 'play' ? 'edit' : 'play';
            updateModeUI();
            document.getElementById('message-box').innerHTML = createMessage('info', `Switched to ${mode.toUpperCase()} Mode.`);
            
            if (!animationFrameId) animate();
        }

        // --- UI & EVENT HANDLERS ---
        
        function initializeView() {
            // Setup ResizeObserver to handle screen/container changes
            const observer = new ResizeObserver(() => {
                handleResize();
            });
            const gameContainer = document.getElementById('game-container');
            if(gameContainer) {
                observer.observe(gameContainer);
            }
            
            if (gameState === 'menu') {
                document.getElementById('app-content').classList.add('hidden');
                document.getElementById('menu-screen').classList.remove('hidden');
            } else {
                document.getElementById('app-content').classList.remove('hidden');
                document.getElementById('menu-screen').classList.add('hidden');
            }
            // Initial call to set canvas size correctly
            handleResize(); 
        }

        document.addEventListener('keydown', (e) => {
            if (mode === 'play') {
                if (isMoving && e.key !== 'z' && e.key !== 'Z') return; 

                switch (e.key.toLowerCase()) {
                    case 'arrowup':
                    case 'w':
                        movePlayer(0, -1);
                        break;
                    case 'arrowdown':
                    case 's':
                        movePlayer(0, 1);
                        break;
                    case 'arrowleft':
                    case 'a':
                        movePlayer(-1, 0);
                        break;
                    case 'arrowright':
                    case 'd':
                        movePlayer(1, 0);
                        break;
                    case 'z': 
                        useWeapon();
                        break;
                    default:
                        return;
                }
                e.preventDefault();
            }
        });

        if (canvas) canvas.addEventListener('click', handleTileClick);
        
        document.getElementById('mode-toggle-btn').addEventListener('click', toggleMode);
        document.getElementById('play-game-btn').addEventListener('click', startGame);
        document.getElementById('repair-btn').addEventListener('click', repairWeapon);
        document.getElementById('upgrade-btn').addEventListener('click', upgradeWeapon);
        document.getElementById('use-weapon-btn').addEventListener('click', useWeapon);
        // New event listener for the cheat button
        document.getElementById('mega-gold-btn').addEventListener('click', grantMegaGold);

        function createMessage(type, content) {
            const baseClasses = 'p-3 rounded-lg text-sm transition-all duration-300';
            let classes = '';

            switch(type) {
                case 'success':
                    classes = 'bg-green-100 text-green-800';
                    break;
                case 'error':
                    classes = 'bg-red-100 text-red-800';
                    break;
                case 'warning':
                    classes = 'bg-yellow-100 text-yellow-800';
                    break;
                case 'combat': 
                    classes = 'bg-red-50 text-red-700 border-l-4 border-red-400 font-semibold';
                    break;
                case 'info':
                default:
                    classes = 'bg-blue-100 text-blue-800';
                    break;
            }

            return `<div class="${baseClasses} ${classes} shadow-md">${content}</div>`;
        }

        // --- INITIALIZATION ---

        window.onload = () => {
            initFirebase();
            initializeView(); 
            // drawGame is called inside handleResize
        };

    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        /* Ensure body and html take full height and remove padding for clean fullscreen overlay */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }

        /* Responsive Canvas Container */
        #game-container {
            position: relative; 
            width: 100%; /* Take full width of parent */
            aspect-ratio: 1 / 1; /* Maintain a 1:1 square ratio */
            max-width: 800px; /* Cap the max size on very large screens */
        }
        
        #gameCanvas {
            background-color: #333;
            border: 4px solid #1a202c;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            touch-action: none; 
            filter: grayscale(30%) saturate(80%) hue-rotate(-10deg); 
            /* CRITICAL: Canvas style to fill 100% of the dynamically sized container */
            width: 100%;
            height: 100%;
        }

        /* --- SWORD VISUAL STYLES --- */
        #playerWeaponVisual {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0; 
            pointer-events: none; 
            z-index: 10;
            transition: transform 0.1s linear; 
        }

        .sword-blade {
            width: 6px;
            height: 30px; 
            background-color: #d1d5db; 
            position: absolute;
            bottom: 0;
            left: -3px; 
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            transform: rotate(45deg); 
            transform-origin: 0 0; 
        }

        .sword-blade::after {
            content: '';
            position: absolute;
            top: 28px; 
            left: -4px; 
            width: 14px;
            height: 4px;
            background-color: #7b3f00; 
            border-radius: 1px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        @keyframes sword-swing {
            0% { transform: rotate(45deg); }
            50% { transform: rotate(225deg) scale(1.1); } 
            100% { transform: rotate(45deg); }
        }

        .swinging {
            animation: sword-swing 0.3s ease-out;
        }
        /* --- END SWORD VISUAL STYLES --- */

        .control-panel {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* --- COOLER MENU STYLING --- */

        /* Animated Title Glow */
        @keyframes title-flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow: 
                    0 0 7px rgba(255, 255, 255, 0.8),
                    0 0 10px rgba(255, 255, 255, 0.6),
                    0 0 20px rgba(100, 200, 255, 0.4),
                    0 0 30px rgba(100, 200, 255, 0.3);
                opacity: 1;
            }
            20%, 24%, 55% {        
                text-shadow: none;
                opacity: 0.8;
            }
        }

        /* Menu Background with Texture and Vignette */
        #menu-screen {
            /* Deep, dark background color */
            background-color: #1c1c1c; 
            /* Subtle texture overlay for a stone/dungeon look */
            background-image: radial-gradient(circle at center, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.8) 100%),
                              repeating-linear-gradient(
                45deg, rgba(50, 50, 50, 0.1) 0, rgba(50, 50, 50, 0.1) 1px, transparent 1px, transparent 100px
            );
        }

        #menu-title {
            font-family: 'Press Start 2P', cursive;
            color: #d1d5db; /* Light gray for the base */
            letter-spacing: 5px;
            animation: title-flicker 4s infinite alternate; /* Apply the flicker animation */
        }
        
        /* Stylized Compass Icon Animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinning-icon {
            animation: spin 30s linear infinite;
        }

        /* Improved Button Styling */
        .menu-button {
            padding: 1rem 3rem;
            background-color: #a8a29e; /* Stone/Metal color */
            border: 4px solid #44403c; /* Dark border */
            color: #1c1c1c;
            font-weight: bold;
            font-family: 'Press Start 2P', cursive; /* Use game font for button */
            text-shadow: 1px 1px #e5e7eb;
            box-shadow: 0 6px 0 #44403c, 0 10px 20px rgba(0,0,0,0.6);
            transition: transform 0.1s, background-color 0.1s, box-shadow 0.1s;
        }

        .menu-button:hover {
            background-color: #c0b9b3; 
            transform: translateY(-4px);
            box-shadow: 0 8px 0 #44403c, 0 12px 25px rgba(0,0,0,0.8);
        }

        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #44403c;
        }
        /* --- END COOLER MENU STYLING --- */

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
    </style>
</head>
<body class="min-h-screen flex items-start justify-center p-2 sm:p-4">

    <!-- Main Menu Screen Overlay -->
    <div id="menu-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center hidden">
        
        <!-- Stylized Icon/Graphic -->
        <svg class="w-20 h-20 mb-6 text-yellow-500 spinning-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2v2m0 16v2M4 12H2m20 0h-2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"></path>
        </svg>

        <h1 id="menu-title" class="text-3xl sm:text-5xl lg:text-6xl text-center">2D EXPLORER</h1>
        
        <p class="mt-4 text-gray-400 text-sm italic font-semibold">
            The Collaborative Map Dungeon
        </p>

        <button id="play-game-btn" class="menu-button rounded-lg mt-12">
            START QUEST
        </button>
        
        <p class="mt-12 text-gray-500 text-xs italic">
            Created by the Dungeon Master (Your ID is used for saving.)
        </p>
    </div>

    <!-- Existing Game Content Container - Now fully responsive -->
    <div id="app-content" class="flex flex-col lg:flex-row gap-4 sm:gap-8 w-full max-w-7xl">
        
        <!-- Game Canvas Area - Takes up available space -->
        <div class="flex flex-col items-center justify-center lg:flex-1 w-full">
            <h1 class="text-xl sm:text-3xl font-bold text-gray-800 mb-4 text-center">The Explorer's Canvas</h1>
            
            <!-- Game Container is constrained to maintain 1:1 aspect ratio -->
            <div id="game-container" class="relative">
                <!-- Canvas has no fixed size here, it gets set by JS (handleResize) -->
                <canvas id="gameCanvas"></canvas>
                
                <div id="playerWeaponVisual" style="display: none;">
                    <div id="swordVisual" class="sword-blade"></div>
                </div>
            </div>
        </div>

        <!-- Control Panel - Width adapts on smaller screens -->
        <div class="control-panel p-4 sm:p-6 lg:w-96 w-full mt-4 lg:mt-0">
            <h2 class="text-xl sm:text-2xl font-bold text-gray-700 mb-4 border-b pb-2">Admin Tools & Progression</h2>
            
            <div class="space-y-4">
                
                <p id="mode-status" class="text-lg font-semibold text-gray-600">Current Mode: PLAY</p>
                
                <button id="mode-toggle-btn" class="w-full py-3 px-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-md transition duration-150 ease-in-out transform hover:scale-[1.02]">
                    Switch to Edit Mode
                </button>
                
                <!-- NEW ADMIN BUTTON for 1M Gold, initially hidden in Play Mode -->
                <button id="mega-gold-btn" class="w-full py-2 px-4 bg-red-800 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-150 ease-in-out text-sm" style="display: none;">
                    ADMIN: Grant 1,000,000 Gold
                </button>

                <div id="message-box" class="min-h-[40px] mt-4">
                    <div class="p-3 rounded-lg text-sm bg-blue-100 text-blue-800 shadow-md">Loading game data...</div>
                </div>

                <!-- Weapon Station -->
                <div class="border-t pt-4">
                    <h3 class="text-xl font-bold text-gray-700 mb-2">Weapon Station</h3>
                    <p id="currency-display" class="text-lg font-semibold text-yellow-700 mb-4">Gold: 0</p>
                    
                    <!-- Weapon Display -->
                    <div id="weapon-display" class="bg-gray-100 p-3 rounded-lg space-y-2 border border-gray-300">
                        <p class="text-sm text-gray-500">Weapon loading...</p>
                    </div>

                    <!-- Controls -->
                    <div class="flex gap-2 mt-4">
                        <button id="repair-btn" class="flex-1 py-2 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg transition text-sm">
                            Repair (0 G)
                        </button>
                        <button id="upgrade-btn" class="flex-1 py-2 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg transition text-sm">
                            Upgrade (Lv.2 - 0 G)
                        </button>
                    </div>
                    <button id="use-weapon-btn" class="w-full mt-2 py-2 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-lg transition">
                        Use Weapon (Z key)
                    </button>
                </div>


                <div class="border-t pt-4">
                    <p class="font-bold text-gray-700 mb-2">Instructions:</p>
                    
                    <div id="play-instruction" class="space-y-2 text-sm text-gray-600">
                        <p class="font-semibold text-green-700">Play Mode:</p>
                        <ul class="list-disc list-inside ml-2">
                            <li>Use **WASD** or **Arrow Keys** to move.</li>
                            <li>Press **Z** or click **Use Weapon** to swing the sword and attack goblins!</li>
                        </ul>
                    </div>
                    
                    <div id="edit-instruction" class="space-y-2 text-sm text-gray-600 hidden">
                        <p class="font-semibold text-red-700">Edit Mode (Admin):</p>
                        <ul class="list-disc list-inside ml-2">
                            <li>Click on any tile to cycle through tile types.</li>
                            <li>Use the **ADMIN button** above to get instant gold for testing upgrades!</li>
                        </ul>
                    </div>
                </div>

                <div class="border-t pt-4 mt-4">
                    <p id="user-id-display" class="text-xs text-gray-400">User ID: Loading...</p>
                    <p class="text-xs text-gray-400">Map Data and Enemy state are Public/Shared.</p>
                    <p class="text-xs text-gray-400">Player Data (Gold/Weapon) is Private.</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
