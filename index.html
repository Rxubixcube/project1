<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Explorer & Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        // Import Firebase components
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, collection, getDoc, query, where, getDocs, runTransaction, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set log level for debugging
        setLogLevel('debug');

        // Global variables provided by the environment (MANDATORY)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- GAME CONSTANTS & ANIMATION SETTINGS ---
        const TILE_SIZE = 40; // Pixels per tile
        const MAP_SIZE = 20; // 20x20 tiles
        const CANVAS_SIZE = MAP_SIZE * TILE_SIZE; // 800x800

        const LERP_FACTOR = 0.15; // Controls the speed of smooth movement
        const TRAIL_FADE_RATE = 0.05;

        const CURRENCY_NAME = 'Gold';
        const STARTING_GOLD = 500;
        
        // Weapon templates define base stats and repair cost
        const WEAPON_TEMPLATES = {
            'sword': { name: 'Iron Sword', baseAttack: 5, baseDurability: 50, repairCost: 50 },
            'bow': { name: 'Advanced Bow', baseAttack: 4, baseDurability: 40, repairCost: 40 },
            'katana': { name: 'Samurai Katana', baseAttack: 6, baseDurability: 45, repairCost: 60 }
        };
        // Multipliers for weapon scaling
        const DURABILITY_BONUS_PER_LEVEL = 25;
        const ATTACK_BONUS_PER_LEVEL = 3;

        // Tile IDs and their properties
        const TILE_TYPES = {
            GRASS: 0,
            WALL: 1,
            WATER: 2,
            ROAD: 3,
            FOREST: 4,
            BUILDING: 5, 
            TREE: 6,      
        };

        const TILE_PROPERTIES = [
            { id: TILE_TYPES.GRASS, name: 'Grass', color: '#689f38', traversable: true },
            { id: TILE_TYPES.WALL, name: 'Wall', color: '#5d4037', traversable: false },
            { id: TILE_TYPES.WATER, name: 'Water', color: '#03a9f4', traversable: false },
            { id: TILE_TYPES.ROAD, name: 'Road', color: '#bcaaa4', traversable: true },
            { id: TILE_TYPES.FOREST, name: 'Forest', color: '#4a6b2c', traversable: true },
            { id: TILE_TYPES.BUILDING, name: 'Building', color: '#795548', traversable: false }, 
            { id: TILE_TYPES.TREE, name: 'Tree', color: '#004d40', traversable: false },         
        ];

        // --- GAME STATE ---
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;

        let mapData = createEmptyMap(MAP_SIZE);
        // Player state now includes currency and weapon
        let player = { 
            x: 9, 
            y: 9, 
            visualX: 9, 
            visualY: 9,
            currency: 0, 
            weapon: null 
        }; 
        let mode = 'play'; 
        let gameState = 'menu'; 
        
        // Animation state
        let isMoving = false; 
        let animationFrameId = null; 
        let trailEffect = { x: -1, y: -1, opacity: 0 }; 

        // --- FIREBASE SETUP AND AUTHENTICATION (FIXED) ---

        async function initFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing.");
                    document.getElementById('message-box').innerHTML = createMessage('error', 'Firebase configuration is missing. Cannot save data.');
                    return;
                }
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // CRITICAL FIX: The listener must be set up *after* getAuth() has been called on the initialized app.
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        if (!userId) { // Prevents re-running startApp if already authenticated
                            userId = user.uid;
                            isAuthReady = true;
                            document.getElementById('user-id-display').textContent = `User ID: ${userId}`;
                            console.log("Authentication successful. User ID:", userId);
                            startListeners();
                            player.visualX = player.x; 
                            player.visualY = player.y;
                            player.weapon = player.weapon || initializePlayerWeapon();
                            if (gameState === 'game' && !animationFrameId) {
                                animate();
                            }
                        }
                    } else {
                        console.log("No user signed in.");
                        isAuthReady = true; // Mark as ready even if anonymous
                    }
                });

                // Sign in attempt (will trigger the onAuthStateChanged listener)
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                
            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                document.getElementById('message-box').innerHTML = createMessage('error', `Authentication failed: ${error.message}`);
            }
        }

        // --- DATA PATH HELPERS ---

        // Public path for the shared map data
        function getMapDocRef() {
            return doc(db, 'artifacts', appId, 'public', 'data', 'exploration_game', 'main_map');
        }

        // Private path for the user's player state
        function getPlayerStateDocRef(uid) {
            return doc(db, 'artifacts', appId, 'users', uid, 'game_state', 'player_state');
        }

        // --- WEAPON LOGIC ---

        /**
         * Initializes a new weapon object, setting base level.
         * @param {string} type - The key from WEAPON_TEMPLATES.
         * @returns {object} The initialized weapon object.
         */
        function initializePlayerWeapon(type = 'sword') {
            const newWeapon = {
                type: type,
                level: 1,
                currentDurability: 0, // Will be set to max by calculateWeaponStats
            };
            return calculateWeaponStats(newWeapon);
        }

        /**
         * Calculates max durability and attack based on weapon level.
         * @param {object} weapon - The weapon state object.
         * @returns {object} The updated weapon state object.
         */
        function calculateWeaponStats(weapon) {
            const template = WEAPON_TEMPLATES[weapon.type];
            const level = weapon.level;

            // Stats scale linearly with level
            const maxDurability = template.baseDurability + (level - 1) * DURABILITY_BONUS_PER_LEVEL;
            const attackPower = template.baseAttack + (level - 1) * ATTACK_BONUS_PER_LEVEL;
            
            weapon.maxDurability = maxDurability;
            weapon.attackPower = attackPower;
            
            // If current durability is undefined (new object) or higher than new max (shouldn't happen), set to max.
            if (weapon.currentDurability === undefined || weapon.currentDurability > maxDurability) {
                weapon.currentDurability = maxDurability;
            }

            return weapon;
        }

        /**
         * Attempts to upgrade the player's current weapon.
         */
        function upgradeWeapon() {
            if (!player.weapon) return;
            if (player.weapon.currentDurability < player.weapon.maxDurability) {
                document.getElementById('message-box').innerHTML = createMessage('warning', `Weapon must be fully repaired before upgrading!`);
                return;
            }
            
            const nextLevel = player.weapon.level + 1;
            // Upgrade Cost: Base Repair Cost * (Level^2)
            const upgradeCost = WEAPON_TEMPLATES[player.weapon.type].repairCost * nextLevel * nextLevel; 

            if (player.currency < upgradeCost) {
                document.getElementById('message-box').innerHTML = createMessage('error', `Not enough ${CURRENCY_NAME}! Requires ${upgradeCost}.`);
                return;
            }

            player.currency -= upgradeCost;
            player.weapon.level = nextLevel;
            
            // Recalculate stats and set durability to new max
            player.weapon = calculateWeaponStats(player.weapon); 
            player.weapon.currentDurability = player.weapon.maxDurability;

            document.getElementById('message-box').innerHTML = createMessage('success', `Weapon upgraded to Level ${nextLevel}! Cost: ${upgradeCost} ${CURRENCY_NAME}.`);
            savePlayerState();
            updateWeaponUI();
        }

        /**
         * Attempts to repair the player's current weapon to max durability.
         */
        function repairWeapon() {
            if (!player.weapon) return;
            if (player.weapon.currentDurability === player.weapon.maxDurability) {
                document.getElementById('message-box').innerHTML = createMessage('info', `Weapon durability is already full.`);
                return;
            }

            const missingDurability = player.weapon.maxDurability - player.weapon.currentDurability;
            // Repair cost is 1 Gold per point of missing durability
            const repairCost = missingDurability * 1; 

            if (player.currency < repairCost) {
                document.getElementById('message-box').innerHTML = createMessage('error', `Not enough ${CURRENCY_NAME}! Requires ${repairCost} to fully repair.`);
                return;
            }

            player.currency -= repairCost;
            player.weapon.currentDurability = player.weapon.maxDurability;

            document.getElementById('message-box').innerHTML = createMessage('success', `Weapon fully repaired! Cost: ${repairCost} ${CURRENCY_NAME}.`);
            savePlayerState();
            updateWeaponUI();
        }

        /**
         * Mock function to simulate weapon usage and durability loss.
         */
        function useWeapon() {
            if (!player.weapon) return;
            if (player.weapon.currentDurability <= 0) {
                document.getElementById('message-box').innerHTML = createMessage('warning', `Weapon is broken! Must be repaired.`);
                return;
            }
            
            // Randomly lose 1 to 5 durability
            const damage = Math.floor(Math.random() * 5) + 1;
            player.weapon.currentDurability = Math.max(0, player.weapon.currentDurability - damage);

            document.getElementById('message-box').innerHTML = createMessage('info', `Weapon used (Damage: ${player.weapon.attackPower})! Durability lost: ${damage}.`);
            
            // If weapon breaks, notify user
            if (player.weapon.currentDurability === 0) {
                document.getElementById('message-box').innerHTML = createMessage('error', `Weapon BROKEN! Please repair it now.`);
            }

            savePlayerState();
            updateWeaponUI();
        }

        // --- MAP AND PLAYER MANAGEMENT ---

        function createEmptyMap(size) {
            return Array(size).fill(0).map(() => Array(size).fill(TILE_TYPES.GRASS));
        }

        /**
         * Generates a new, random map.
         */
        function generateProceduralMap() {
            const newMap = createEmptyMap(MAP_SIZE);
            let riverY = Math.floor(MAP_SIZE * 0.3 + Math.random() * MAP_SIZE * 0.4); 
            
            for (let x = 0; x < MAP_SIZE; x++) {
                if (riverY >= 0 && riverY < MAP_SIZE) {
                    newMap[riverY][x] = TILE_TYPES.WATER;
                }
                if (riverY + 1 < MAP_SIZE) newMap[riverY + 1][x] = TILE_TYPES.WATER;

                const shift = Math.floor(Math.random() * 3) - 1; 
                riverY += shift;
                riverY = Math.max(0, Math.min(MAP_SIZE - 2, riverY));
            }

            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (newMap[y][x] === TILE_TYPES.WATER) continue;
                    if (Math.random() < 0.10) { 
                        newMap[y][x] = TILE_TYPES.TREE;
                    } else if (Math.random() < 0.05) { 
                        newMap[y][x] = TILE_TYPES.FOREST;
                    }
                }
            }
            
            newMap[player.y][player.x] = TILE_TYPES.GRASS;

            return newMap;
        }


        function startListeners() {
            if (!isAuthReady || !userId || !db) return;

            // 1. Listen for Map Data (Public)
            onSnapshot(getMapDocRef(), (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    if (data.tiles) {
                        try {
                            mapData = JSON.parse(data.tiles); 
                            console.log("Map data loaded/updated from Firestore.");
                        } catch (e) {
                            console.error("Error parsing map data:", e);
                            document.getElementById('message-box').innerHTML = createMessage('error', 'Map data corruption detected. Resetting map.');
                            mapData = createEmptyMap(MAP_SIZE);
                        }
                    }
                } else {
                    console.log("No map data found. Initializing new map...");
                    saveMapToFirestore(createEmptyMap(MAP_SIZE));
                }
            }, (error) => {
                console.error("Error listening to map data:", error);
                document.getElementById('message-box').innerHTML = createMessage('warning', 'Failed to load map data in real-time. Check console for details.');
            });

            // 2. Listen for Player State (Private)
            onSnapshot(getPlayerStateDocRef(userId), (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    
                    player.x = data.x ?? player.x;
                    player.y = data.y ?? player.y;
                    
                    // Load Currency
                    player.currency = data.currency ?? STARTING_GOLD; 
                    
                    // Load Weapon state
                    if (data.weapon) {
                        try {
                            // Calculate stats based on level, then load current durability
                            const loadedWeapon = JSON.parse(data.weapon);
                            player.weapon = calculateWeaponStats(loadedWeapon);
                            player.weapon.currentDurability = loadedWeapon.currentDurability ?? player.weapon.maxDurability;
                        } catch (e) {
                            console.error("Error parsing weapon data:", e);
                            player.weapon = initializePlayerWeapon();
                        }
                    } else {
                        player.weapon = initializePlayerWeapon();
                    }
                    
                    console.log(`Player state loaded/updated: (${player.x}, ${player.y})`);
                    
                    if (gameState === 'game') {
                        updateWeaponUI();
                        if (!animationFrameId) {
                            animate();
                        }
                    }
                } else {
                    console.log("No player state found. Initializing state...");
                    player.currency = STARTING_GOLD;
                    player.weapon = initializePlayerWeapon();
                    savePlayerState();
                }
            }, (error) => {
                console.error("Error listening to player state:", error);
                document.getElementById('message-box').innerHTML = createMessage('warning', 'Failed to load player state. Check console for details.');
            });
        }

        async function saveMapToFirestore(newMap = mapData) {
            if (!isAuthReady || !userId || !db) {
                document.getElementById('message-box').innerHTML = createMessage('error', 'Cannot save: Authentication not ready.');
                return;
            }

            try {
                const serializedMap = JSON.stringify(newMap);

                await setDoc(getMapDocRef(), {
                    tiles: serializedMap,
                    last_updated: new Date().toISOString(),
                    editor_id: userId
                });
                console.log("Map saved successfully!");
                document.getElementById('message-box').innerHTML = createMessage('success', 'Map updated and saved.');
            } catch (error) {
                console.error("Error saving map:", error);
                document.getElementById('message-box').innerHTML = createMessage('error', `Save failed: ${error.message}`);
            }
        }

        async function savePlayerState() {
            if (!isAuthReady || !userId || !db) return;
            try {
                await setDoc(getPlayerStateDocRef(userId), {
                    x: player.x,
                    y: player.y,
                    currency: player.currency,
                    // Save the weapon object (only the type, level, and currentDurability)
                    weapon: JSON.stringify({
                        type: player.weapon.type,
                        level: player.weapon.level,
                        currentDurability: player.weapon.currentDurability
                    }),
                    last_update: new Date().toISOString()
                }, { merge: true });
            } catch (error) {
                console.error("Error saving player state:", error);
            }
        }

        // --- GAME CANVAS DRAWING & ANIMATION ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        /**
         * Main animation loop.
         */
        function animate() {
            // 1. Interpolate visual position (Smooth Movement)
            const targetX = player.x;
            const targetY = player.y;

            player.visualX += (targetX - player.visualX) * LERP_FACTOR;
            player.visualY += (targetY - player.visualY) * LERP_FACTOR;

            const distanceSquared = (targetX - player.visualX)**2 + (targetY - player.visualY)**2;
            
            if (distanceSquared < 0.001) { 
                player.visualX = player.x;
                player.visualY = player.y;
                isMoving = false;
            } else {
                isMoving = true;
            }

            // 2. Fade out trail effect
            if (trailEffect.opacity > 0) {
                trailEffect.opacity = Math.max(0, trailEffect.opacity - TRAIL_FADE_RATE);
            }

            // 3. Redraw the entire game state
            drawGame();

            // 4. Loop: Continue if in game state or if movement/effects are ongoing
            if (gameState === 'game' || isMoving || trailEffect.opacity > 0) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                animationFrameId = null; // Stop loop when idle
            }
        }

        // Helper function to draw the avatar icon with smooth effects
        function drawAvatar(x, y, size) {
            
            let scaleFactor = 1.0;
            if (isMoving) {
                const time = performance.now() * 0.005; 
                // Subtle bobbing effect
                scaleFactor = 1.0 + Math.abs(Math.sin(time * 5)) * 0.1; 
            }

            const centerX = x * TILE_SIZE + TILE_SIZE / 2;
            const centerY = y * TILE_SIZE + TILE_SIZE / 2;
            const headRadius = size / 3;
            const bodyHeight = size / 2;

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Apply scaling transform
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(scaleFactor, scaleFactor);
            ctx.translate(-centerX, -centerY);


            // 1. Head (Circle) - Duller color
            ctx.fillStyle = '#b7a288'; 
            ctx.beginPath();
            ctx.arc(centerX, centerY - headRadius / 2, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // 2. Body (Rectangle/Pants) - Grayish uniform
            ctx.fillStyle = '#787d83'; 
            ctx.fillRect(centerX - headRadius, centerY + headRadius * 0.5, headRadius * 2, bodyHeight);
            
            ctx.restore(); // Restore transformation

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        /**
         * Draws a pseudo-3D tree tile.
         */
        function drawTree(x, y) {
            const startX = x * TILE_SIZE;
            const startY = y * TILE_SIZE; 
            const size = TILE_SIZE;

            const baseGrassColor = TILE_PROPERTIES[TILE_TYPES.GRASS].color;
            const trunkColor = '#8d6e63'; 
            const darkGreen = '#004d40'; 
            const lightGreen = '#388e3c'; 

            ctx.fillStyle = baseGrassColor;
            ctx.fillRect(startX, startY, size, size);

            const trunkWidth = size * 0.2;
            const trunkHeight = size * 0.4;
            const trunkX = startX + (size - trunkWidth) / 2;
            const trunkY = startY + size - trunkHeight;
            ctx.fillStyle = trunkColor;
            ctx.fillRect(trunkX, trunkY, trunkWidth, trunkHeight);

            const canopyRadius = size * 0.45;
            const centerX = startX + size / 2;
            const centerY = startY + size * 0.3; 

            // Shadow Layer
            ctx.fillStyle = darkGreen;
            ctx.beginPath();
            ctx.arc(centerX + 3, centerY + 5, canopyRadius, 0, Math.PI * 2);
            ctx.fill();

            // Main Layer
            ctx.fillStyle = darkGreen;
            ctx.beginPath();
            ctx.arc(centerX, centerY, canopyRadius, 0, Math.PI * 2);
            ctx.fill();

            // Highlight Layer
            ctx.fillStyle = lightGreen;
            ctx.beginPath();
            ctx.ellipse(centerX - 5, centerY - 5, canopyRadius * 0.7, canopyRadius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ground Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(centerX, startY + size - 5, trunkWidth * 2, trunkWidth * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGame() {
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;

            // 0. Draw Fading Trail (Smooth Movement Effect)
            if (trailEffect.opacity > 0) {
                const trailX = trailEffect.x * TILE_SIZE + TILE_SIZE / 2;
                const trailY = trailEffect.y * TILE_SIZE + TILE_SIZE / 2;
                ctx.fillStyle = `rgba(255, 255, 255, ${trailEffect.opacity * 0.5})`; 
                ctx.beginPath();
                ctx.arc(trailX, trailY, TILE_SIZE * 0.4 * (1 + (1 - trailEffect.opacity)), 0, Math.PI * 2); 
                ctx.fill();
            }

            // 1. Draw the map
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const tileId = mapData[y] ? mapData[y][x] : TILE_TYPES.GRASS;
                    const tile = TILE_PROPERTIES.find(p => p.id === tileId) || TILE_PROPERTIES[0];
                    
                    if (tileId === TILE_TYPES.TREE) {
                        drawTree(x, y);
                    } else {
                        ctx.fillStyle = tile.color;
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    if (mode === 'edit') {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // 2. Draw the player
            if (mode === 'play') {
                drawAvatar(player.visualX, player.visualY, TILE_SIZE);
            }

            // 3. Draw current mode indicator on canvas
            ctx.fillStyle = mode === 'edit' ? 'rgba(255, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ctx.font = '700 16px Inter, sans-serif';
            ctx.fillText(mode.toUpperCase(), 10, 20);
        }

        // --- MOVEMENT LOGIC (PLAY MODE) ---

        function isTileTraversable(x, y) {
            if (x < 0 || x >= MAP_SIZE || y < 0 || y >= MAP_SIZE) return false;
            const tileId = mapData[y] ? mapData[y][x] : TILE_TYPES.GRASS;
            const tile = TILE_PROPERTIES.find(p => p.id === tileId);
            return tile ? tile.traversable : true;
        }

        function movePlayer(dx, dy) {
            if (gameState !== 'game' || mode !== 'play') return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (isTileTraversable(newX, newY)) {
                trailEffect.x = player.x;
                trailEffect.y = player.y;
                trailEffect.opacity = 1.0;

                player.x = newX;
                player.y = newY;

                savePlayerState(); 

                if (!animationFrameId) {
                    animate();
                }

            } else {
                document.getElementById('message-box').innerHTML = createMessage('info', 'Movement blocked!');
            }
        }

        // --- EDITOR LOGIC (EDIT MODE) ---

        function handleTileClick(event) {
            if (gameState !== 'game' || mode !== 'edit') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = Math.floor(((event.clientX - rect.left) * scaleX) / TILE_SIZE);
            const y = Math.floor(((event.clientY - rect.top) * scaleY) / TILE_SIZE);

            if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                const currentTileId = mapData[y][x];
                const nextTileId = (currentTileId + 1) % TILE_PROPERTIES.length;

                const newMap = mapData.map(row => [...row]);
                newMap[y][x] = nextTileId;

                mapData = newMap;
                
                saveMapToFirestore(newMap);
            }
        }

        // --- UI DRAWING & GAME MODE LOGIC ---

        function updateWeaponUI() {
            if (!player.weapon) return;
            
            // 1. Update Currency
            document.getElementById('currency-display').textContent = `${CURRENCY_NAME}: ${player.currency} G`;

            // 2. Weapon Display
            const w = player.weapon;
            const template = WEAPON_TEMPLATES[w.type];
            
            const missingDurability = w.maxDurability - w.currentDurability;
            const repairCost = missingDurability * 1; 
            const upgradeCost = template.repairCost * (w.level + 1) * (w.level + 1);
            
            // Durability Bar Logic
            const durabilityPct = (w.currentDurability / w.maxDurability) * 100;
            let durabilityColor = 'bg-green-500';
            if (durabilityPct < 50) durabilityColor = 'bg-yellow-500';
            if (durabilityPct < 20) durabilityColor = 'bg-red-500';

            const weaponHtml = `
                <p class="text-lg font-bold">${template.name} <span class="text-indigo-600">(Lv. ${w.level})</span></p>
                <p class="text-sm">Attack Power: ${w.attackPower} <span class="text-gray-500">(+${w.attackPower - template.baseAttack})</span></p>
                
                <div class="mt-2">
                    <p class="text-xs font-medium">Durability: ${w.currentDurability} / ${w.maxDurability}</p>
                    <div class="w-full bg-gray-300 rounded-full h-2.5">
                        <div class="${durabilityColor} h-2.5 rounded-full transition-all duration-300" style="width: ${durabilityPct}%"></div>
                    </div>
                </div>
            `;
            
            document.getElementById('weapon-display').innerHTML = weaponHtml;

            // 3. Button Status and Text
            const repairBtn = document.getElementById('repair-btn');
            const upgradeBtn = document.getElementById('upgrade-btn');

            repairBtn.disabled = w.currentDurability === w.maxDurability || player.currency < repairCost;
            upgradeBtn.disabled = w.currentDurability !== w.maxDurability || player.currency < upgradeCost;

            repairBtn.textContent = w.currentDurability === w.maxDurability ? 'Repaired (Full)' : `Repair (${repairCost} G)`;
            upgradeBtn.textContent = `Upgrade (Lv.${w.level + 1} - ${upgradeCost} G)`;
        }


        function startGame() {
            gameState = 'game';
            
            const generatedMap = generateProceduralMap();
            mapData = generatedMap; 
            saveMapToFirestore(generatedMap); 
            
            // Ensure player state is initialized if starting locally
            player.currency = player.currency || STARTING_GOLD;
            player.weapon = player.weapon || initializePlayerWeapon();
            player.visualX = player.x;
            player.visualY = player.y;

            document.getElementById('app-content').classList.remove('hidden');
            document.getElementById('menu-screen').classList.add('hidden');
            mode = 'play'; 
            document.getElementById('mode-status').textContent = `Current Mode: ${mode.toUpperCase()}`;
            document.getElementById('mode-toggle-btn').textContent = 'Switch to Edit Mode';
            document.getElementById('edit-instruction').style.display = 'none';
            document.getElementById('play-instruction').style.display = 'block';
            
            updateWeaponUI(); // Initial UI draw
            if (!animationFrameId) {
                animate();
            }
        }

        function toggleMode() {
            if (gameState !== 'game') return;

            mode = mode === 'play' ? 'edit' : 'play';
            document.getElementById('mode-toggle-btn').textContent = mode === 'play' ? 'Switch to Edit Mode' : 'Switch to Play Mode';
            document.getElementById('mode-status').textContent = `Current Mode: ${mode.toUpperCase()}`;
            document.getElementById('edit-instruction').style.display = mode === 'edit' ? 'block' : 'none';
            document.getElementById('play-instruction').style.display = mode === 'play' ? 'block' : 'none';
            document.getElementById('message-box').innerHTML = createMessage('info', `Switched to ${mode.toUpperCase()} Mode.`);
            
            if (!animationFrameId) {
                animate();
            }
        }

        // --- UI & EVENT HANDLERS ---
        
        function initializeView() {
            if (gameState === 'menu') {
                document.getElementById('app-content').classList.add('hidden');
                document.getElementById('menu-screen').classList.remove('hidden');
            } else {
                document.getElementById('app-content').classList.remove('hidden');
                document.getElementById('menu-screen').classList.add('hidden');
            }
        }

        document.addEventListener('keydown', (e) => {
            if (mode === 'play') {
                if (isMoving) return; 

                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                        movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                    case 's':
                        movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                        movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                    case 'd':
                        movePlayer(1, 0);
                        break;
                    default:
                        return;
                }
                e.preventDefault();
            }
        });

        canvas.addEventListener('click', handleTileClick);
        
        // Add new button handlers
        document.getElementById('mode-toggle-btn').addEventListener('click', toggleMode);
        document.getElementById('play-game-btn').addEventListener('click', startGame);
        document.getElementById('repair-btn').addEventListener('click', repairWeapon);
        document.getElementById('upgrade-btn').addEventListener('click', upgradeWeapon);
        document.getElementById('use-weapon-btn').addEventListener('click', useWeapon);

        function createMessage(type, content) {
            const baseClasses = 'p-3 rounded-lg text-sm transition-all duration-300';
            let classes = '';

            switch(type) {
                case 'success':
                    classes = 'bg-green-100 text-green-800';
                    break;
                case 'error':
                    classes = 'bg-red-100 text-red-800';
                    break;
                case 'warning':
                    classes = 'bg-yellow-100 text-yellow-800';
                    break;
                case 'info':
                default:
                    classes = 'bg-blue-100 text-blue-800';
                    break;
            }

            return `<div class="${baseClasses} ${classes} shadow-md">${content}</div>`;
        }

        // --- INITIALIZATION ---

        window.onload = () => {
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            initFirebase();
            initializeView(); 
            drawGame(); 
        };

    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            position: relative; 
        }
        #gameCanvas {
            background-color: #333;
            border: 4px solid #1a202c;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            touch-action: none; 
            filter: grayscale(30%) saturate(80%) hue-rotate(-10deg); 
        }
        .control-panel {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* --- MENU STYLING --- */
        #menu-screen {
            background-image: repeating-linear-gradient(
                -45deg,
                rgba(0, 0, 0, 0.2) 0,
                rgba(0, 0, 0, 0.2) 1px,
                transparent 1px,
                transparent 50px
            );
            background-color: #1a202c;
        }

        #menu-title {
            font-family: 'Press Start 2P', cursive;
            color: white;
            text-shadow: 4px 4px #4a6b2c; 
            letter-spacing: 5px;
            margin-bottom: 2rem;
        }

        .menu-button {
            padding: 1rem 3rem;
            background-color: #689f38; 
            border: 4px solid #385e1c;
            color: #fff;
            font-weight: bold;
            font-family: 'Inter', sans-serif;
            text-shadow: 1px 1px #333;
            box-shadow: 0 4px 0 #385e1c, 0 6px 10px rgba(0,0,0,0.5);
            transition: transform 0.1s, background-color 0.1s;
        }

        .menu-button:hover {
            background-color: #8bc34a; 
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #385e1c, 0 8px 15px rgba(0,0,0,0.6);
        }

        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #385e1c;
        }
        
        /* Disabled button style */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-start justify-center">

    <!-- Main Menu Screen Overlay -->
    <div id="menu-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center hidden">
        <h1 id="menu-title" class="text-4xl sm:text-6xl">2D EXPLORER</h1>
        <button id="play-game-btn" class="menu-button rounded-md mt-8">
            PLAY
        </button>
        <p class="mt-12 text-gray-400 text-sm italic">
            A Collaborative 2D Map Editor
        </p>
    </div>

    <!-- Existing Game Content Container -->
    <div id="app-content" class="flex flex-col lg:flex-row gap-8 w-full max-w-7xl">
        
        <!-- Game Canvas Area -->
        <div class="flex flex-col items-center justify-center lg:flex-1">
            <h1 class="text-3xl font-bold text-gray-800 mb-4">The Explorer's Canvas</h1>
            <canvas id="gameCanvas" width="800" height="800"></canvas>
        </div>

        <!-- Control Panel -->
        <div class="control-panel p-6 lg:w-96">
            <h2 class="text-2xl font-bold text-gray-700 mb-4 border-b pb-2">Admin Tools & Progression</h2>
            
            <div class="space-y-4">
                
                <p id="mode-status" class="text-lg font-semibold text-gray-600">Current Mode: PLAY</p>
                
                <button id="mode-toggle-btn" class="w-full py-3 px-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-md transition duration-150 ease-in-out transform hover:scale-[1.02]">
                    Switch to Edit Mode
                </button>

                <div id="message-box" class="min-h-[40px] mt-4">
                    <div class="p-3 rounded-lg text-sm bg-blue-100 text-blue-800 shadow-md">Loading game data...</div>
                </div>

                <!-- NEW: Weapon Station -->
                <div class="border-t pt-4">
                    <h3 class="text-xl font-bold text-gray-700 mb-2">Weapon Station</h3>
                    <p id="currency-display" class="text-lg font-semibold text-yellow-700 mb-4">Gold: 0</p>
                    
                    <!-- Weapon Display -->
                    <div id="weapon-display" class="bg-gray-100 p-3 rounded-lg space-y-2 border border-gray-300">
                        <!-- Weapon details inserted by JS -->
                        <p class="text-sm text-gray-500">Weapon loading...</p>
                    </div>

                    <!-- Controls -->
                    <div class="flex gap-2 mt-4">
                        <button id="repair-btn" class="flex-1 py-2 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg transition text-sm">
                            Repair (0 G)
                        </button>
                        <button id="upgrade-btn" class="flex-1 py-2 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg transition text-sm">
                            Upgrade (Lv.2 - 0 G)
                        </button>
                    </div>
                    <button id="use-weapon-btn" class="w-full mt-2 py-2 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-lg transition">
                        Use Weapon (Mock Combat)
                    </button>
                </div>


                <div class="border-t pt-4">
                    <p class="font-bold text-gray-700 mb-2">Instructions:</p>
                    
                    <div id="play-instruction" class="space-y-2 text-sm text-gray-600">
                        <p class="font-semibold text-green-700">Play Mode:</p>
                        <ul class="list-disc list-inside ml-2">
                            <li>Use **WASD** or **Arrow Keys** to move smoothly.</li>
                            <li>Use the **Weapon Station** to manage your gear!</li>
                        </ul>
                    </div>
                    
                    <div id="edit-instruction" class="space-y-2 text-sm text-gray-600 hidden">
                        <p class="font-semibold text-red-700">Edit Mode (Admin):</p>
                        <ul class="list-disc list-inside ml-2">
                            <li>Click on any tile to cycle through tile types (Grass, Wall, Water, etc.).</li>
                            <li>The map is shared and **saved instantly** to Firestore!</li>
                        </ul>
                    </div>
                </div>

                <div class="border-t pt-4 mt-4">
                    <p id="user-id-display" class="text-xs text-gray-400">User ID: Loading...</p>
                    <p class="text-xs text-gray-400">Map Data is Public/Shared.</p>
                    <p class="text-xs text-gray-400">Player Data (Gold/Weapon) is Private.</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
